<%@ jet package="CodeGenerator" class="UART001Template" 
imports="java.util.* com.ifx.davex.appjetinteract.App2JetInterface" %>
<% App2JetInterface app = (App2JetInterface) argument; %>
<% String Baseuri = "app/uart001/";%>
/*CODE_BLOCK_BEGIN[UART001.c]*/
/******************************************************************************
 Copyright (c) 2011, Infineon Technologies AG                                **
 All rights reserved.                                                        **
                                                                             **
 Redistribution and use in source and binary forms, with or without          **
 modification,are permitted provided that the following conditions are met:  **
                                                                             **
 *Redistributions of source code must retain the above copyright notice,     **
 this list of conditions and the following disclaimer.                       **
 *Redistributions in binary form must reproduce the above copyright notice,  **
 this list of conditions and the following disclaimer in the documentation   **
 and/or other materials provided with the distribution.                      **
 *Neither the name of the copyright holders nor the names of its             **
 contributors may be used to endorse or promote products derived from this   **
 software without specific prior written permission.                         **
                                                                             **
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" **
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   **
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  **
 ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  **
 LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR        **
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        **
 SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   **
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     **
 CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      **
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  **
 POSSIBILITY OF SUCH DAMAGE.                                                 **
                                                                             **
 To improve the quality of the software, users are encouraged to share       **
 modifications, enhancements or bug fixes with Infineon Technologies AG      **
 dave@infineon.com).                                                         **
                                                                             **
*******************************************************************************
**                                                                           **
**                                                                           **
** PLATFORM : Infineon XMC4000/ XMC1000 Series                               **
**                                                                           **
** COMPILER : Compiler Independent                                           **
**                                                                           **
** AUTHOR   : App Developer                                                  **
**                                                                           **
** MAY BE CHANGED BY USER [yes/no]: Yes                                      **
**                                                                           **
** MODIFICATION DATE : Jul 25, 2013                                          **
**                                                                           **
******************************************************************************/
/******************************************************************************
**                      Author(s) Identity                                   **
*******************************************************************************
**                                                                           **
** Initials     Name                                                         **
** --------------------------------------------------------------------------**
** PAE          App Developer                                                **
******************************************************************************/
/**
 * @file UART001.c
 * 
 * @App Version UART001 <<%= app.getAppVersion(Baseuri)%>>
 *
 * @brief  UART001 App provides non reentrant APIs for higher level Apps 
 *          which can be used in a Non -RTOS environment. 
 *           Limitations of Simple UART App
 *           a) Read/Write functions are non reentrant.
 *           b) No support for DMA mode
 */
/*
 * Revision History
 * 04 Dec 2012 v1.0.4  Changes from 1.0.2 are
 *                     1. Modified for baud calculation during initialization.
 *                     2. Modified the macros FUNCTION_ENTRY, FUNCTION_EXIT and
 *                     ERROR
 *                     3. The hard coded values are replaced with macros in
 *                     UART001_lConfigureBaudRate() function.
 *                     4. The PCTQ value update in BRG register is removed as
 *                     the value is taken as zero.
 *                     5. Modified as per coding guidelines and MISRA checks
 * 26 Mar 2013 v1.0.10 1. Updated for the baud calculation in UART001_lInit()
 *                     function.
 *                     2. Updated for the alignment in revision history.
 *                     3. Updated the UART001_Init() function for disabling the
 *                     clock gating signal for XMC1000 devices.
 *                     4. Updated function UART001_lConfigureBaudRate() for the
 *                     Baud rate calculation.
 * 25 Jul 2013 v1.0.16 1. Removed TBIF bit configuration from UART001_lInit as 
 *                     polling is not used in the UART001 App. 
 *                     2. Added open-drain output configuration for Half duplex 
 *                     operation mode to allow the wired-AND connection in
 *                     multiple transmitter communication.
 *                     3. Added CCR.MODE configurations in UART001_lInit() 
 *                     & UART001_Configure to disable the UART mode before 
 *                     configuring USIC registers & to enable the UART mode 
 *                     after configurations to avoid unintended edges.
 *                     4. Modified the input parameter of 
 *                     UART001_WriteDataMultiple() from const uint16_t* to 
 *                     uint16_t* to maintain backward compatibility.
 *                     5. TX pin set logic high (1) before configuring Open 
 *                     Drain mode for Half Duplex operation mode.                     	                                                     
 */
/******************************************************************************
 ** INCLUDE FILES                                                            **
 *****************************************************************************/

#include <DAVE3.h>

<% String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null; 
   boolean DBGApp = false;   
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}   
//   }  
  } %>

<% if (!DBGApp) { %>  
/*****************************************************************************
              DUMMY DEFINTIONS OF DEBUG LOG MACROS
*****************************************************************************/
/*These definitions are included here to avoid compilation errors,
 since the DBG002 app is not part of the project. All the macros are defined
 as empty*/ 
#ifndef _DBG002_H_

#define DBG002_RegisterCallBack(A,B,C)
#define DBG002_I(e) 
#define DBG002_IG(e,g) 
#define DBG002_IH(e,h) 
#define DBG002_IP(e,p) 
#define DBG002_IGH(e,g,h) 
#define DBG002_IGP(e,g,p) 
#define DBG002_IHP(e,h,p) 
#define DBG002_IGHP(e,g,h,p) 
#define DBG002_N(e) 
#define DBG002_NG(e,g) 
#define DBG002_NH(e,h) 
#define DBG002_NP(e,p) 
#define DBG002_NGH(e,g,h) 
#define DBG002_NGP(e,g,p) 
#define DBG002_NHP(e,h,p) 
#define DBG002_NGHP(e,g,h,p) 
#define DBG002_ID(e) 
#define DBG002_IS(e) 
#define DBG002_ISG(e,g) 
#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)
#define DBG002_CRITICAL(groupid,messageid,length,value)
#define DBG002_ERROR(groupid,messageid,length,value)
#define DBG002_WARNING(groupid,messageid,length,value)
#define DBG002_INFO(groupid,messageid,length,value)
#define DBG002_TRACE(groupid,messageid,length,value)
#define DBG002_FUNCTION_ENTRY(GID, Status) 
#define DBG002_FUNCTION_EXIT(GID, Status) 

#endif/* End of defintions of dummy Debug Log macros*/
<% } %>                  
<% String Uarturi = "peripheral/usic/"; %>
<% String MappedUri = null; %>
<% String UnitInst = null; %>
<% String appInst  = null; %>
<% double clockfreq = 0; %>
<% int Is44Device = -1; %>
<% int Is42Device = -1; %>
<% int Is45Device = -1; %>
<% int Is1xDevice = -1; %>
<% Is44Device = ((app.getSoftwareId().substring(0,2).compareTo("44")==0)?1:0); %>
<% Is42Device = ((app.getSoftwareId().substring(0,2).compareTo("42")==0)?1:0); %>
<% Is45Device = ((app.getSoftwareId().substring(0,2).compareTo("45")==0)?1:0); %>
<% Is1xDevice = ((app.getSoftwareId().substring(0,1).compareTo("1")==0)?1:0); %>  

<% ArrayList<String> appsList7 = (ArrayList<String>)(app.getApps("app/uart001/"));
 for (String appIns : appsList7 ) {
 appInst = appIns.substring(appIns.lastIndexOf("/")+1);%>
<% MappedUri = app.getMappedUri(Baseuri + appInst + "/channel"); %>
<% if((MappedUri != null) && (MappedUri != "")) {  %>
<% if(Is1xDevice == 1){
  clockfreq = app.getDoubleValue (Baseuri + appInst + "/clockapp/clk002_irMCLK" );
  }
  else if ((Is45Device==1)||(Is44Device==1)||(Is42Device==1)){
  clockfreq = app.getDoubleValue (Baseuri + appInst + "/clockapp/clk001_iroActualFreqPB" );
  }
  else{}
  %> 
  /* System Core clock frequency in MHz */
#define UART001_CLOCK  <%= clockfreq%>F
<%break;%>
<% } %>
<% else { %>
// CHANNEL IS NOT MAPPED
<% } %>
<%} %>

/******************************************************************************
**                      Private Macro Definitions                            **
******************************************************************************/
#define APP_GID DBG002_GID_UART001

/*Flag Offset Transmit Receive Buffer */
#define UART001_FLAG_OFFSET                            (0x05U)

#define UART001_MAX_VALUE                              (1024U)
/* (DCTQ + 1) DCTQ value is 9 */
#define UART001_DCTQ_VALUE                             (0x0AUL)

/******************************************************************************
**                      Private Type Definitions                             **
******************************************************************************/


/******************************************************************************
**                 Private Function Declarations:
******************************************************************************/

/* Initializes the App based on User provide configuration. */
void UART001_lInit (const UART001_HandleType* Handle);

/* Give optimized PDIV and STEP value for the given baud rate */ 
void UART001_lConfigureBaudRate\
                           (uint32_t BaudRate,uint32_t* Pdiv,uint32_t* Step);
/* to find the real type */
float UART001_labsRealType(float Number);                           
/******************************************************************************
**                      Global Constant Definitions                          **
******************************************************************************/

/******************************************************************************
**                      Global Variable Definitions                          **
******************************************************************************/

/******************************************************************************
**                      Private Constant Definitions                         **
******************************************************************************/

/******************************************************************************
**                 Function like macro definitions                           **
******************************************************************************/

/******************************************************************************
**                      Private Function Definitions                         **
******************************************************************************/
/* Initializes the App based on User provide configuration. */
 
void UART001_lInit (const UART001_HandleType* Handle)
{
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;

  DBG002_FUNCTION_ENTRY(APP_GID,UART001_FUN_ENTRY);
 /* <<<DD_UART001_API_1>>>*/
 
  /** UART initialization  */

  /* Disable UART mode before configuring all USIC registers to avoid unintended edges */ 
  UartRegs->CCR &= ~( ((uint32_t)(UART_MODE  & USIC_CH_CCR_MODE_Msk))); 

  /* Enable the USIC Channel */
  UartRegs->KSCFG |= ((((uint32_t)0x01  & USIC_CH_KSCFG_MODEN_Msk)) | \
                       (((uint32_t)0x01 << USIC_CH_KSCFG_BPMODEN_Pos) &  \
                         USIC_CH_KSCFG_BPMODEN_Msk)); 
   
  /* Configuration of USIC Channel Fractional Divider */

  /* Fractional divider mode selected */
  UartRegs->FDR |= (((uint32_t)0x02 << USIC_CH_FDR_DM_Pos) \
                                                         & USIC_CH_FDR_DM_Msk);
  
  /* Step value */
  UartRegs->FDR |= ((Handle->BGR_STEP) & USIC_CH_FDR_STEP_Msk);
          
  /* The PreDivider for CTQ, PCTQ = 0  */
  /* The Denominator for CTQ, DCTQ = 16 */
    
  UartRegs->BRG |= \
	  ((((uint32_t)(Handle->BGR_PCTQ) << USIC_CH_BRG_PCTQ_Pos) & \
		  	     USIC_CH_BRG_PCTQ_Msk) | \
      (((uint32_t)(Handle->BGR_DCTQ) << USIC_CH_BRG_DCTQ_Pos) & \
	     USIC_CH_BRG_DCTQ_Msk) | \
      (((uint32_t)(Handle->BGR_PDIV) << USIC_CH_BRG_PDIV_Pos) &  \
	     USIC_CH_BRG_PDIV_Msk));
 
  /* Configuration of USIC Shift Control */
  
  /* Transmit/Receive LSB first is selected  */
  /* Transmission Mode (TRM) = 1  */
  /* Passive Data Level (PDL) = 1 */
  UartRegs->SCTR |= ((((uint32_t)0x01  << USIC_CH_SCTR_PDL_Pos) & \
    USIC_CH_SCTR_PDL_Msk ) | \
    (((uint32_t)0x01  <<  USIC_CH_SCTR_TRM_Pos ) &   USIC_CH_SCTR_TRM_Msk ));
  /* Set Word Length (WLE) & Frame Length (FLE) */
  UartRegs->SCTR |= ((((uint32_t)Handle->DataBits  << USIC_CH_SCTR_FLE_Pos) & \
                      USIC_CH_SCTR_FLE_Msk ) | \
                     (((uint32_t)Handle->DataBits  << USIC_CH_SCTR_WLE_Pos) & \
                        USIC_CH_SCTR_WLE_Msk));

       
  /* Configuration of USIC Transmit Control/Status Register */ 
  /* TBUF Data Enable (TDEN) = 1 */
  /* TBUF Data Single Shot Mode (TDSSM) = 1 */
	
  UartRegs->TCSR |= ((((uint32_t)0x01  << USIC_CH_TCSR_TDEN_Pos) & \
    USIC_CH_TCSR_TDEN_Msk ) | \
    (((uint32_t)0x01  << USIC_CH_TCSR_TDSSM_Pos) & USIC_CH_TCSR_TDSSM_Msk));

  /* Configuration of Protocol Control Register */ 
  /* Sample Mode (SMD) = 1 */
  /* 1 Stop bit is selected */   
  /* Sample Point (SP) as configured */
  /* Pulse Length (PL) = 0 */
  
  UartRegs->PCR_ASCMode |= ((((uint32_t)0x01 & USIC_CH_PCR_ASCMode_SMD_Msk)) |\
    (((uint32_t)Handle->StopBit  << USIC_CH_PCR_ASCMode_STPB_Pos) & \
    USIC_CH_PCR_ASCMode_STPB_Msk) | \
    (((uint32_t)(Handle->BGR_SP) << USIC_CH_PCR_ASCMode_SP_Pos) & \
    USIC_CH_PCR_ASCMode_SP_Msk));
      
  if(Handle->RecvNoiseEn)
  {
   	/* Enable Receiver Noise Interrupt*/  
    UartRegs->PCR_ASCMode |=(((uint32_t)0x01  << USIC_CH_PCR_CTR5_Pos) & \
		  	  	  	  	  USIC_CH_PCR_CTR5_Msk); 
  }
  
  if(Handle->FormatErrEn)
  {
   	/* Enable Format Error Interrupt*/  
    UartRegs->PCR_ASCMode |=(((uint32_t)0x01  << USIC_CH_PCR_CTR6_Pos) & \
		  	  	  	  	                                    USIC_CH_PCR_CTR6_Msk); 
  }
  
  if(Handle->FrameFinEn)
  {
   	/* Enable Frame Finished Interrupt*/  
    UartRegs->PCR_ASCMode |=(((uint32_t)0x01  << USIC_CH_PCR_CTR7_Pos) & \
		  	                                   	  	  	  USIC_CH_PCR_CTR7_Msk); 
  } 
	
  /* Configuration of Transmitter Buffer Control Register */ 
  UartRegs->TBCTR |= ((((uint32_t)Handle->TxLimit  << \
                    USIC_CH_TBCTR_LIMIT_Pos ) & USIC_CH_TBCTR_LIMIT_Msk));
    
  /* Configuration of Receiver Buffer Control Register */ 
  UartRegs->RBCTR |= ((((uint32_t)Handle->RxLimit  << \
                       USIC_CH_RBCTR_LIMIT_Pos) & USIC_CH_RBCTR_LIMIT_Msk) | \
	                    (((uint32_t)0x01 << USIC_CH_RBCTR_LOF_Pos) & \
                       USIC_CH_RBCTR_LOF_Msk));
   
  /* Configuration of Channel Control Register */ 
  /* parity generation is disabled*/
  UartRegs->CCR |= (((uint32_t)(UART_MODE  & USIC_CH_CCR_MODE_Msk)) | \
                    (((uint32_t)Handle->Parity  << USIC_CH_CCR_PM_Pos) & \
                     USIC_CH_CCR_PM_Msk));
  
  DBG002_FUNCTION_EXIT(APP_GID,UART001_FUN_EXIT);
}


float UART001_labsRealType(float Number)
{
   float return_value;
	if (Number < 0.0){
		return_value = -Number;
	}
	else{
		return_value = Number;
	}
	return return_value;
}

/* Give optimized PDIV and STEP value for the given baud rate */ 
void UART001_lConfigureBaudRate\
                              (uint32_t BaudRate,uint32_t* Pdiv,uint32_t* Step)
{
	uint32_t fdr_step = 0x00U;
	uint32_t brg_pdiv = 0x00U;
	uint32_t divisor_in = BaudRate ;
	/* fPB / 1024 * (Brg_dctq + 1) */
	uint32_t dividend_in = 0U;
	uint32_t divisor[4];
	uint32_t dividend[4];
	uint32_t remainder[4];
	uint32_t divisor_array[4];
	uint32_t dividend_array[4];
	uint32_t div_array[4];
	uint32_t max, frac,divisor1,divisor2,dividend1,dividend2;
	uint32_t array_count,array_count_1,array_count_2;
	uint32_t do_while_break = 0U;
	uint32_t temp = 0U;
	float div_factor;
	uint8_t loop_cnt;
	bool swapped;
	dividend_in = (uint32_t)((uint32_t)(UART001_CLOCK * 1000000)/ \
                    	(UART001_MAX_VALUE * UART001_DCTQ_VALUE)); 
	/* swap if divisor_in/dividend_in > max_divisor/max_dividend */
	div_factor = (float) divisor_in/(float) dividend_in;
	if ( div_factor > 1.0)
	{
		max = UART001_MAX_VALUE;
		swapped = 1U;
		temp = divisor_in;
		divisor_in = dividend_in;
		dividend_in = temp;
	}
	else
	{
		swapped = 0U;
		max = UART001_MAX_VALUE;
	}
	/*Init parameters*/
	loop_cnt = 0U;
	array_count = 0U;
	array_count_1 = 0U;
	divisor[0] = divisor_in;
	remainder[0] = dividend_in;
	divisor_array[0] = 1U;
	dividend_array[0] = 0U;
	do {
			++loop_cnt;
			array_count_2 = array_count_1; /* on first loop is not used */
			array_count_1 = array_count;
			array_count = loop_cnt % 4U;
			dividend[array_count] = divisor[array_count_1];
			
			divisor[array_count] = remainder[array_count_1];
			
			div_array[array_count] = dividend[array_count] / divisor[array_count];
			
			remainder[array_count] = dividend[array_count] % divisor[array_count];
			
			/* This executed only on first loop */
			if (loop_cnt == 1U)
			{ 
				divisor_array[1] = div_array[1];
				dividend_array[1] = 1U;
			}
			else
			{
				divisor_array[array_count] = \
				      (div_array[array_count] * divisor_array[array_count_1]) + \
				       divisor_array[array_count_2];
				dividend_array[array_count] = \
				      (div_array[array_count] * dividend_array[array_count_1]) + \
				       dividend_array[array_count_2];
			}
			if (dividend_array[array_count] > max) 
			{
				divisor1 = divisor_array[array_count_1];
				dividend1 = dividend_array[array_count_1];
				frac = (uint32_t)(max - dividend_array[array_count_2]) / \
				                               dividend_array[array_count_1];
				divisor2 = (uint32_t)(frac * divisor_array[array_count-1]) + \
				                                divisor_array[array_count-2];
				dividend2 = (uint32_t)(frac * dividend_array[array_count-1]) + \
				                               dividend_array[array_count_2];
				/* Swap if required */
				if (swapped) {
						/* Swap divisor1 and dividend1 */
						temp = divisor1;
						divisor1 = dividend1;
						dividend1 = temp;
						/* Swap divisor2 and dividend2 */
						temp = divisor2;
						divisor2 = dividend2;
						dividend2 = temp;
					}
				/* Remove if one of has divisor 0 */
				if ((dividend1 == 0U) || (divisor1 == 0U)) {
					fdr_step = divisor2;
					brg_pdiv = dividend2;
				}else if ((dividend2 == 0U) || (divisor2 == 0U)) {
					fdr_step = divisor1;
					brg_pdiv = dividend1;
				}else { 
					/*  Find the most nearest to target division */
					if (UART001_labsRealType(div_factor - \
					    ((float) divisor1 / (float) dividend1 )) > \
					    UART001_labsRealType(div_factor - \
					    ((float) divisor2 / (float) dividend2 ))) 
					{
						fdr_step = divisor2;
						brg_pdiv = dividend2;
					}else {
						fdr_step = divisor1;
						brg_pdiv = dividend1;
					}
				}
				do_while_break = 0x05U;
			}
			else if (remainder[array_count]== 0U) 
			{
				fdr_step = divisor_array[array_count];
				brg_pdiv = dividend_array[array_count];
				if (swapped)
				{
					/* Swap fdr_step and brg_pdiv */
					temp = fdr_step;
					fdr_step = brg_pdiv;
					brg_pdiv = temp;
				}
				do_while_break = 0x05U;
			}
			else {
			  /* Do Nothing */
			}
		} while (do_while_break != 0x05U);

	if(fdr_step >= UART001_MAX_VALUE)
	{
	   fdr_step = 1023U;
	}

	*Step = (uint32_t)fdr_step;

	*Pdiv = (uint32_t)(brg_pdiv - 1U);
}
/******************************************************************************
**                      Public Function Definitions                          **
******************************************************************************/
void UART001_Init(void)
{

<% ArrayList<String> appsList = (ArrayList<String>)(app.getApps("app/uart001/"));
 for (String appIns : appsList ) {
 appInst = appIns.substring(appIns.lastIndexOf("/")+1);%>
<% MappedUri = app.getMappedUri(Baseuri + appInst + "/channel"); %>
<% if((MappedUri != null) && (MappedUri != "")) { 
 UnitInst = MappedUri.substring(MappedUri .length()-11,MappedUri.indexOf("/channel/")); 
 int Unit = Integer.parseInt(UnitInst); %>
<% if(Unit == 0)  { %>
<%if ((Is44Device==1)||(Is42Device==1)||(Is1xDevice==1))
  {%>
    /* Disable the USIC0 clock gating */
    /* 
     * The disabling of the clock gating is applicable only for
     * XMC4400, XMC4200 and XMC1000 devices.
     */
<%if ((Is1xDevice==1))  {%>
    SCU_GENERAL->PASSWD = 0x000000C0UL;
    WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, \
                                  SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);<%}%>
    SET_BIT(SCU_CLK->CGATCLR0, SCU_CLK_CGATCLR0_USIC0_Pos);
  <%if ((Is1xDevice==1))    {%>
    while ((SCU_CLK->CLKCR)&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
    {
  	 ;
    }
    SCU_GENERAL->PASSWD = 0x000000C3UL;     <%}%>
  <%}%>
  <%if ((Is45Device==1)||(Is44Device==1)||(Is42Device==1))
  {%>
/* Reset the Peripheral*/
    RESET001_DeassertReset(PER0_USIC<%=UnitInst%>);
    <%}%>
  <% } else { %>
<%if ((Is44Device==1)||(Is42Device==1)||(Is1xDevice==1))
  {%>
    /* Disable the USIC1 clock gating */
    /* 
     * The disabling of the clock gating is applicable only for
     * XMC4400, XMC4200 and XMC1000 devices.
     */
<%if ((Is1xDevice==1))  {%>
    SCU_GENERAL->PASSWD = 0x000000C0UL;
    WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, \
                                  SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);<%}%>
    SET_BIT(SCU_CLK->CGATCLR1, SCU_CLK_CGATCLR1_USIC1_Pos);
    <%if ((Is1xDevice==1)) {%>
    while ((SCU_CLK->CLKCR)&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
    {
  	  ;
    }
    SCU_GENERAL->PASSWD = 0x000000C3UL;     <%}%>
  <%}%>
    <%if ((Is45Device==1)||(Is44Device==1)||(Is42Device==1))
  {%>
    /* Reset the Peripheral*/
    RESET001_DeassertReset(PER1_USIC<%=UnitInst%>); <% } %> 
       <%}%>
    UART001_lInit(&UART001_Handle<%=appInst%>); 
  <% String pinUri = app.getMappedUri(Baseuri + appInst +"/uart_txpin"); %>
   <% if ((pinUri != null) && (pinUri.trim() != "")) { %>
    <% String portNo = pinUri.substring(pinUri.indexOf("port/p/")+7,pinUri.indexOf("/pad/")); %>
    <% String pinNo = pinUri.substring(pinUri.indexOf("/pad/")+5,pinUri.length()); %>   
    <% int PDR_PD1 = app.getIntegerValue(Baseuri + appInst +"/uart_txpin/pdr_pd"); %>
    <% int Pin = Integer.parseInt(pinNo);%>
    <% int Oper_Mode = app.getIntegerValue(Baseuri + appInst +"/uart001_OprModeTemp"); %>
    <%if ((Oper_Mode == 1)) {%>
    /* Configure TX Pin in Open-drain mode to allow the Wired-AND connection */
    PORT<%=portNo%>->OMR |= ((uint32_t)0x01 << <%=pinNo%>);
    <%if(Pin < 4) { %>
    PORT<%=portNo%>->IOCR0 |= (0x18 << <%=(3+(Pin*8))%>);
    <%}else if (Pin >= 4 && Pin <= 7) {  
    Pin = Pin - 4; %>
    PORT<%=portNo%>->IOCR4 |= (0x18 << <%=(3+(Pin*8))%>);
    <%} else if (Pin >= 8 && Pin <= 11) { 
    Pin = Pin - 8; %>
    PORT<%=portNo%>->IOCR8 |= (0x18 << <%=(3+(Pin*8))%>);
    <%} else if (Pin >= 12 && Pin <= 15) { 
    Pin = Pin - 12; %>
    PORT<%=portNo%>->IOCR12 |= (0x18 << <%=(3+(Pin*8))%>);
    <%}}%>    
    /* Configuration of TX Pin <%=portNo%>.<%=pinNo%> based on User configuration */     
    <%if ((Is45Device==1)||(Is44Device==1)||(Is42Device==1))
  {%>
    /* PDR_PD = <%=PDR_PD1%>  */

    <% if(Pin < 8) {%>
    PORT<%=portNo%>->PDR0  &= (~(PORT<%=portNo%>_PDR0_PD<%=Pin%>_Msk));
    <% if(PDR_PD1 != 0) {%>
    PORT<%=portNo%>->PDR0  |= (((uint32_t)<%=PDR_PD1%> << PORT<%=portNo%>_PDR0_PD<%=Pin%>_Pos) & \
                                             PORT<%=portNo%>_PDR0_PD<%=Pin%>_Msk);
    <% }%>
    <% } else {%>
    PORT<%=portNo%>->PDR1 &= (~(PORT<%=portNo%>_PDR1_PD<%=Pin%>_Msk));
    <% if(PDR_PD1 != 0) {%>
    PORT<%=portNo%>->PDR1 |= (((uint32_t)<%=PDR_PD1%> << PORT<%=portNo%>_PDR1_PD<%=Pin%>_Pos) & \
                                        PORT<%=portNo%>_PDR1_PD<%=Pin%>_Msk);    
    <% }%>
    <%} %> 
  <% }%>   
    <%} else { %>
    /* TXPIN instance (no.<%= appInst %>) is not mapped to any port pin. */
    <%} %>    
    <% String pinUri2 = app.getMappedUri(Baseuri + appInst +"/uart_rxpin"); %>
    <% if ((pinUri2 != null) && (pinUri2.trim() != "")) { %>
    <% String portNo2 = pinUri2.substring(pinUri2.indexOf("port/p/")+7,pinUri2.indexOf("/pad/")); %>
    <% String pinNo2 = pinUri2.substring(pinUri.indexOf("/pad/")+5,pinUri2.length());%> 
    /* Configuration of RX Pin <%=portNo2%>.<%=pinNo2%> based on User configuration */
    <% int Pin2 = Integer.parseInt(pinNo2);%>
    <% int IOCR_PCR = app.getIntegerValue(Baseuri + appInst +"/uart001_inputchardummy");%>
    <% if(Pin2 < 4) { %>
    <% if(IOCR_PCR != 0) {%>
	PORT<%=portNo2%>->IOCR0 |= ((uint32_t)<%=IOCR_PCR%> << <%=(3+(Pin2*8))%>);
    <% }%>
	<%}else if (Pin2 >= 4 && Pin2 <= 7) {  
	Pin2 = Pin2 - 4; %>
    <% if(IOCR_PCR != 0) {%>
	PORT<%=portNo2%>->IOCR4 |= ((uint32_t)<%=IOCR_PCR%> << <%=(3+(Pin2*8))%>);
    <% }%>
	<%} else if (Pin2 >= 8 && Pin2 <= 11) { 
	Pin2 = Pin2 - 8; %>
    <% if(IOCR_PCR != 0) {%>
	PORT<%=portNo2%>->IOCR8 |= ((uint32_t)<%=IOCR_PCR%> << <%=(3+(Pin2*8))%>);
    <% }%>
	<%} else if (Pin2 >= 12 && Pin2 <= 15) { 
	Pin2 = Pin2 - 12; %>
    <% if(IOCR_PCR != 0) {%>
	PORT<%=portNo2%>->IOCR12 |= ((uint32_t)<%=IOCR_PCR%> << <%=(3+(Pin2*8))%>);
    <% }%>
	<%}%>     
     <%} else { %>
     /* RXPIN instance (no.<%= appInst %>) is not mapped to any port pin. */
     <%} %>
<% } %>
<% else { %>
// CHANNEL IS NOT MAPPED
<% } %>
<%} %>
}
 /* Function provide to reset the App to default values. */
 void  UART001_DeInit (const UART001_HandleType* Handle)
{
  /* <<<DD_UART001_API_2>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,UART001_FUN_ENTRY);
  
    
  DBG002_FUNCTION_EXIT(APP_GID,UART001_FUN_EXIT);
}

/* Function which allows changing of baudrate,parity & stopbit at run time.*/
status_t  UART001_Configure
( 
  const UART001_HandleType* Handle,
  uint32_t BaudRate,
  UART_ParityType Parity,
  UART_StopBitType Stopbit
)
{
   uint32_t Brg_Pdiv = 0x00U;
   uint32_t Fdr_Step = 0x00U;
   uint32_t TXIDLE_status;
   uint32_t RXIDLE_status;
   USIC_CH_TypeDef* UartRegs = Handle->UartRegs;
   status_t Status = (status_t)UART001_ERROR;
   
   DBG002_FUNCTION_ENTRY(APP_GID,UART001_FUN_ENTRY);
   /* <<<DD_UART001_API_3>>>*/

   TXIDLE_status = (uint32_t)\
                 RD_REG(UartRegs->PSR_ASCMode,USIC_CH_PSR_ASCMode_TXIDLE_Msk, \
	                       USIC_CH_PSR_ASCMode_TXIDLE_Pos);

   RXIDLE_status = (uint32_t)\
                 RD_REG(UartRegs->PSR_ASCMode,USIC_CH_PSR_ASCMode_RXIDLE_Msk, \
	                       USIC_CH_PSR_ASCMode_RXIDLE_Pos);
   if(( TXIDLE_status & RXIDLE_status) == 0x01U)
    {
      /* Disable UART mode before configuring all USIC registers to avoid unintended edges */ 
      UartRegs->CCR &= ~( ((uint32_t)(UART_MODE  & USIC_CH_CCR_MODE_Msk)));  
	  
      /* Configuration of USIC Channel Fractional Divider */
      UART001_lConfigureBaudRate(BaudRate,&Brg_Pdiv,&Fdr_Step);

      /* Step value: 0x3FF */
      UartRegs->FDR &= ~(USIC_CH_FDR_STEP_Msk);
      UartRegs->FDR |= ( Fdr_Step & USIC_CH_FDR_STEP_Msk);
              
      /* The PreDivider for CTQ, PCTQ = 0  */
      /* The Denominator for CTQ, DCTQ = 16 */

      UartRegs->BRG &= ~(USIC_CH_BRG_PDIV_Msk);
      UartRegs->BRG |= ((((uint32_t)Brg_Pdiv  << USIC_CH_BRG_PDIV_Pos) \
    		                                          &  USIC_CH_BRG_PDIV_Msk));

      /* Configure StopBit */
      UartRegs->PCR_ASCMode &= ~(USIC_CH_PCR_ASCMode_STPB_Msk);
      UartRegs->PCR_ASCMode |= \
                      (((uint32_t)Stopbit << USIC_CH_PCR_ASCMode_STPB_Pos) & \
                       USIC_CH_PCR_ASCMode_STPB_Msk);
          
      /* Configure Parity*/
      UartRegs->CCR &= ~(USIC_CH_CCR_PM_Msk);
      UartRegs->CCR |= (((UART_MODE  & USIC_CH_CCR_MODE_Msk)) | \
                        (((uint32_t)Parity  << USIC_CH_CCR_PM_Pos) & \
                                                       USIC_CH_CCR_PM_Msk));

      Status = (status_t)DAVEApp_SUCCESS;
    }
    else
    {
      Status = (status_t)UART001_BUSY;
      DBG002_ERROR(APP_GID,Status, 0, NULL);
    }
  DBG002_FUNCTION_EXIT(APP_GID,UART001_FUN_EXIT);
  
  return Status;
}
/* This function reads out  the content of the USIC receive FIFO Buffer. 
 * Returns true in case FIFO is not empty.else  otherwise.
 *
 */

uint32_t UART001_ReadDataMultiple\
            (const UART001_HandleType* Handle,uint16_t* DataPtr,uint32_t Count)
{ 
  uint32_t ReadCount = 0x00U;
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;  
  DBG002_FUNCTION_ENTRY(APP_GID,UART001_FUN_ENTRY);
  /* <<<DD_UART001_API_1>>>*/
  while(! USIC_ubIsRxFIFOempty(UartRegs) && Count)
  {
    *DataPtr = (uint16_t)UartRegs->OUTR;
    Count--;
    ReadCount++;
    DataPtr++;
  }
  DBG002_FUNCTION_EXIT(APP_GID,UART001_FUN_EXIT);
  
  return ReadCount;
}

uint32_t UART001_WriteDataMultiple
(
  const UART001_HandleType* Handle,
  uint16_t* DataPtr,
  uint32_t Count
)
{
  uint32_t WriteCount = 0x00U;
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;
  
  DBG002_FUNCTION_ENTRY(APP_GID,UART001_FUN_ENTRY);
  /* <<<DD_UART001_API_2>>>*/
  while(! USIC_IsTxFIFOfull(UartRegs)&& Count)
  {
    UartRegs->IN[0] = *DataPtr;
    Count--;
    WriteCount++;
    DataPtr++;
  }  
  DBG002_FUNCTION_EXIT(APP_GID,UART001_FUN_EXIT);
  
  return WriteCount;
}


/* Checks the specified Flag status bit.*/

status_t UART001_GetFlagStatus 
(
  const UART001_HandleType* Handle,
  UART001_FlagStatusType Flag
)
{
  status_t Status = (status_t)UART001_RESET;
  uint32_t TempValue = 0x00U;
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;
  
  DBG002_FUNCTION_ENTRY(APP_GID,UART001_FUN_ENTRY);
  /* <<<DD_UART001_API_6>>>*/
  if(Flag <= UART001_ALT_REC_IND_FLAG)
  {
    TempValue = UartRegs->PSR_ASCMode;
    TempValue  &= ((uint32_t)0x01 << (uint32_t)Flag);    
  }
  else if(Flag <= UART001_FIFO_ALTRECV_BUF_FLAG)
  {
    TempValue = UartRegs->TRBSR;
    TempValue  &= ((uint32_t)0x01 << \
                  ((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG));
    
  }
  else
  {
    TempValue = UartRegs->TRBSR;
    TempValue  &= ((uint32_t)0x01 << \
       (((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG) + 0x05U ));
  } 

  if(TempValue != 0x00U)
  {
    Status = (status_t)UART001_SET;
  }
  DBG002_FUNCTION_EXIT(APP_GID,UART001_FUN_EXIT);
  return Status;
}

/* Clears the specified flag status.*/
void UART001_ClearFlag
(
  const UART001_HandleType* Handle,
  UART001_FlagStatusType Flag
)
{

  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;
  
  DBG002_FUNCTION_ENTRY(APP_GID,UART001_FUN_ENTRY);

  /* <<<DD_UART001_API_7>>>*/
  if(Flag <= UART001_ALT_REC_IND_FLAG)
  {
    UartRegs->PSCR  |= ((uint32_t)0x01 << (uint32_t)Flag);    
  }
  else if(Flag <= UART001_FIFO_ALTRECV_BUF_FLAG)
  {
    UartRegs->TRBSCR  |= ((uint32_t)0x01 << \
                 ((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG)); 
  }
  else
  {
    UartRegs->TRBSCR  |= ((uint32_t)0x01 << \
               (((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG) + \
                                                       UART001_FLAG_OFFSET ));
  }  
  DBG002_FUNCTION_EXIT(APP_GID,UART001_FUN_EXIT);
}


/*CODE_BLOCK_END*/
