<%@ jet package="CodeGenerator" class="adcch001c_template"
imports="java.util.* com.ifx.davex.appjetinteract.App2JetInterface" %>
<% App2JetInterface app = (App2JetInterface) argument; %>
<% int Is45Device = -1; %>
<% int Is44Device = -1; %>
<% int Is42Device = -1; %>
<% int Is12Device = -1; %>
<% int Is13Device = -1; %>
<% Is45Device = ((app.getSoftwareId().substring(0,2).compareTo("45")==0)?1:0); %>
<% Is44Device = ((app.getSoftwareId().substring(0,2).compareTo("44")==0)?1:0); %>
<% Is42Device = ((app.getSoftwareId().substring(0,2).compareTo("42")==0)?1:0); %>
<% Is12Device = ((app.getSoftwareId().substring(0,2).compareTo("12")==0)?1:0); %>
<% Is13Device = ((app.getSoftwareId().substring(0,2).compareTo("13")==0)?1:0); %>

/*CODE_BLOCK_BEGIN[ADCCH001.c]*/
/*******************************************************************************
 Copyright (c) 2013, Infineon Technologies AG                                 **
 All rights reserved.                                                         **
                                                                              **
 Redistribution and use in source and binary forms, with or without           **
 modification,are permitted provided that the following conditions are met:   **
                                                                              **
 *Redistributions of source code must retain the above copyright notice,      **
 this list of conditions and the following disclaimer.                        **
 *Redistributions in binary form must reproduce the above copyright notice,   **
 this list of conditions and the following disclaimer in the documentation    **
 and/or other materials provided with the distribution.                       **
 *Neither the name of the copyright holders nor the names of its contributors **
 may be used to endorse or promote products derived from this software without**
 specific prior written permission.                                           **
                                                                              **
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  **
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **
 ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **
 LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **
 SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **
 CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **
 POSSIBILITY OF SUCH DAMAGE.                                                  **
                                                                              **
 To improve the quality of the software, users are encouraged to share        **
 modifications, enhancements or bug fixes with Infineon Technologies AG       **
 dave@infineon.com).                                                          **
                                                                              **
********************************************************************************
**                                                                            **
**                                                                            **
** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **
**                                                                            **
** COMPILER : Compiler Independent                                            **
**                                                                            **
** AUTHOR   : DAVE App Developer                                              **
**                                                                            **
** MAY BE CHANGED BY USER [yes/no]: Yes                                       **
**                                                                            **
** MODIFICATION DATE :  29 Jan 2014                                           **
**                                                                            **
*******************************************************************************/

/*******************************************************************************
**                       Author(s) Identity                                   **
********************************************************************************
**                                                                            **
** Initials     Name                                                          **
** ---------------------------------------------------------------------------**
** PM           DAVE App Developer                                            **
** SSAM         Sridhar Sampath                                               **
*******************************************************************************/

/**
 * @file ADCCH001.c
 *
 * @brief   This file contains the implementation of all public and
 *          private functions of the ADCCH001 App.
 *
 * Change History:
 *
 * Date       version       Details
 * 12-Dec-2012   1.0.6    Initial code added for XMC1000
 * 30-Jan-2013   1.0.8    DBG002 macros added in the code
 * 24-Apr-2013   1.0.14   Ported to XMC4500 step AB and Source Result selection
 *                        Feature added
 * 27-Jun-2013   1.0.16   Boundary flag feature supported.
 *                        In the Header comment section device name changed to
 *                        XMC1000.
 * 30-Aug-2013   1.0.18   Workaround for the boundaryflag registers is removed
 *                        since the registers are available in the header file.
 * 10-Sep-2013   1.0.20   Added support for the following devices under XMC1200
 *                        and XMC1300 Series XMC1201, XMC1202, XMC1301.
 * 27-Sep-2013   1.0.22   1. ADCCH001_GetEmux api is implemented.
 *                        2. ADCCH001_GetFastResult api is implemented.
 *                        3. Gain Configuration supported for XMC12/13 Devices.
 * 29-Oct-2013   1.0.24   1. Reference input name in GUI, Varef is changed to
 *                           Vssc for XMC1200/1300 series devices.
 *                        2. Gain configuration code corrected.
 * 15-Nov-2013   1.0.26   Document updated.
 * 29-Jan-2014   1.0.28   1. Gain Configuration is removed from UI.
 *                        2. Error codes are added in various functions, that can 
 *                        be logged with DBG002 App.
 */

/*******************************************************************************
**                      Include Files                                         **
*******************************************************************************/
#include <DAVE3.h>

<% String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null;
   boolean DBGApp = false;
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}
//   }
  } %>

<% if (!DBGApp) { %>
/*****************************************************************************
              DUMMY DEFINTIONS OF DEBUG LOG MACROS
*****************************************************************************/
/*These definitions are included here to avoid compilation errors,
 since the DBG002 app is not part of the project. All the macros are defined
 as empty*/
#ifndef _DBG002_H_

#define DBG002_RegisterCallBack(A,B,C)
#define DBG002_I(e)
#define DBG002_IG(e,g)
#define DBG002_IH(e,h)
#define DBG002_IP(e,p)
#define DBG002_IGH(e,g,h)
#define DBG002_IGP(e,g,p)
#define DBG002_IHP(e,h,p)
#define DBG002_IGHP(e,g,h,p)
#define DBG002_N(e)
#define DBG002_NG(e,g)
#define DBG002_NH(e,h)
#define DBG002_NP(e,p)
#define DBG002_NGH(e,g,h)
#define DBG002_NGP(e,g,p)
#define DBG002_NHP(e,h,p)
#define DBG002_NGHP(e,g,h,p)
#define DBG002_ID(e)
#define DBG002_IS(e)
#define DBG002_ISG(e,g)
#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)
#define DBG002_CRITICAL(groupid,messageid,length,value)
#define DBG002_ERROR(groupid,messageid,length,value)
#define DBG002_WARNING(groupid,messageid,length,value)
#define DBG002_INFO(groupid,messageid,length,value)
#define DBG002_TRACE(groupid,messageid,length,value)
#define DBG002_FUNCTION_ENTRY(GID, Status)
#define DBG002_FUNCTION_EXIT(GID, Status)

#define DBG002_MESSAGEID_LITERAL

#endif/* End of defintions of dummy Debug Log macros*/
<% } %>

/*******************************************************************************
**                      Private Macro Definitions                             **
*******************************************************************************/
#define APP_GID DBG002_GID_ADCCH001

<% String AppBaseuri = "app/ADCCH001/"; %>
<% String appInst  = null; %>
<% String ChannelUri = null; %>

/*******************************************************************************
**                      Global variables Definitions                          **
** Variables defined temporarily due to updated header files not available.   **
*******************************************************************************/
<% String GroupNo = null; %>
<% ArrayList<String> appsList1 = (ArrayList<String>)(app.getApps("app/ADCCH001/"));%>
<% for (String appIns : appsList1 ) {
  appInst = appIns.substring(appIns.lastIndexOf("/")+1);%>
  <% ChannelUri = app.getMappedUri(AppBaseuri + appInst +"/adcch"); %>
  <% if ((ChannelUri != null) && (ChannelUri.trim() != "")) { %>
    <% GroupNo = ChannelUri.substring(ChannelUri.length()-6,ChannelUri.indexOf("/ch/")); %>
  <%}}%>

/**
 * @cond INTERNAL_DOCS
 */

/*******************************************************************************
 *                 Private Function declarations
 ******************************************************************************/

/**
 * @brief This function initializes ADC channel and result registers \n
 * @param[in] HandlePtr Handle of the ADCCH001 App
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
static void ADCCH001_lInit(const ADCCH001_HandleType* HandlePtr);


/*******************************************************************************
 *                 LOCAL FUNCTIONS DEFINITIONS
 ******************************************************************************/
/**
 * This function initializes ADC channel and result registers as per
 * UI configurations.
 */
static void ADCCH001_lInit(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;
  uint8_t Index = (uint8_t)0;

  if((HandlePtr->DynamicHandlePtr->State == ADCCH001_UNINITIALIZED))
  {
    /* Priority Channel */
    WR_REG( GroupPtr->CHASS,
            ((uint32_t)0x01 << HandlePtr->kChannelNo),
            HandlePtr->kChannelNo,
            (uint32_t)HandlePtr->kPrioChannel
           );
    /* Input class */
    WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo],
            VADC_G_CHCTR_ICLSEL_Msk,
            VADC_G_CHCTR_ICLSEL_Pos,
            (uint32_t)HandlePtr->kIpClassSel
           );
    /* Channel event mode */
    WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo],
            VADC_G_CHCTR_CHEVMODE_Msk,
            VADC_G_CHCTR_CHEVMODE_Pos,
            (uint32_t)HandlePtr->kChEvtmode
           );
    /* reference input selection */
    WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo],
            VADC_G_CHCTR_REFSEL_Msk,
            VADC_G_CHCTR_REFSEL_Pos,
            (uint32_t)HandlePtr->kRefInput
           );
    /* XMC4500: EMUXCSS is not present.  */
    if(HandlePtr->kExtMuxControl == (uint8_t)1)
    {   <%if (Is45Device == 1) { %>
           WR_REG( GroupPtr->EMUXCTR, VADC_G_EMUXCTR_EMUXCH_Msk,
                  VADC_G_EMUXCTR_EMUXCH_Pos, (uint32_t)(HandlePtr->kChannelNo));
        <%} else {%>
              GroupPtr->EMUXCTR |= ((1UL << (VADC_G_EMUXCTR_EMUXCH_Pos +
                                      (HandlePtr->kChannelNo)))); <%} %>
    }
    /*Configure result registers if Fast Compare Mode is not selected */
    if(HandlePtr->kCompareMode == (uint8_t)0)
    {
      /* Upper and Lower Boundary Select */
      WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo],
              ((uint32_t)0xF << VADC_G_CHCTR_BNDSELL_Pos),
              VADC_G_CHCTR_BNDSELL_Pos,
              (uint32_t)HandlePtr->kBoundarySel
             );
      /*Result Alignment */
      WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo],
              VADC_G_CHCTR_RESPOS_Msk,
              VADC_G_CHCTR_RESPOS_Pos,
              (uint32_t)HandlePtr->kResultControl
             );
      /* Data modification mode */
      WR_REG( GroupPtr->RCR[HandlePtr->kStartResultRegNo],
              ((uint32_t)0x3F << VADC_G_RCR_DRCTR_Pos),
              VADC_G_RCR_DRCTR_Pos,
              (uint32_t)HandlePtr->kDataModification
             );
      /* Wait for read mode */
      WR_REG( GroupPtr->RCR[HandlePtr->kStartResultRegNo],
              VADC_G_RCR_WFR_Msk,
              VADC_G_RCR_WFR_Pos,
              (uint32_t)HandlePtr->kWaitForRead
             );
  /* result interrupt */
      WR_REG( GroupPtr->RCR[HandlePtr->kEndResultRegNo],
              VADC_G_RCR_SRGEN_Msk,
              VADC_G_RCR_SRGEN_Pos,
              (uint32_t)HandlePtr->kResultEvtEnable
             );
  /* Setting FEN bit in all result registers except start result register */
      if(HandlePtr->kFIFOEnable == (uint8_t)1)
      {
        for(Index = (HandlePtr->kEndResultRegNo);
            Index <= (HandlePtr->kStartResultRegNo -(uint8_t)1);
            Index++)
        {
           WR_REG( GroupPtr->RCR[Index],
                   VADC_G_RCR_FEN_Msk,
                   VADC_G_RCR_FEN_Pos,
                   (uint32_t)0x1
                 );
        }
      }
    }
/* Write compare value in the result register for the Fast Compare Mode */
    else
    {
      WR_REG( GroupPtr->RES[HandlePtr->kStartResultRegNo],
              VADC_G_RES_RESULT_Msk,
              VADC_G_RES_RESULT_Pos,
              (uint32_t)(HandlePtr->kResultCompVal)
            );
    }
    /* Set boundary flag for all the advanced result registers */
    if(HandlePtr->kBoundaryFlagEnable == (uint8_t)1)
    { <% if(Is45Device == 1) {%>
          WR_REG( GroupPtr->BFL,
               ((uint32_t)0x01 << (HandlePtr->kStartResultRegNo + (uint8_t)16)),
               (HandlePtr->kStartResultRegNo + (uint8_t)16),
               (uint32_t)(0x1));
        <%} else {%>
        WR_REG( GroupPtr->BFL,
              ((uint32_t)0x01 << (HandlePtr->kStartResultRegNo + (uint8_t)16)),
              (HandlePtr->kStartResultRegNo + (uint8_t)16),
              (uint32_t)(HandlePtr->kBoundaryFlagInv));
        WR_REG( GroupPtr->BFL,
                 ((uint32_t)0x01 << (HandlePtr->kStartResultRegNo + (uint8_t)8)),
              (HandlePtr->kStartResultRegNo + (uint8_t)8),
              (uint32_t)(HandlePtr->kBoundaryFlagAct));
        WR_REG( GroupPtr->BFLC,
               ((uint32_t)0xf << (HandlePtr->kStartResultRegNo * (uint8_t)4)),
              (HandlePtr->kStartResultRegNo * (uint8_t)4),
              (uint32_t)(HandlePtr->kBoundaryFlagMode));
     <%}%>}
    <% if((Is12Device == 1) || (Is13Device == 1)) {%>
    /* Set the gain for the configured channels.*/
    if(GroupPtr == VADC_G0) {
    WR_REG_SIZE(SHS0->GNCTR00,
                0xF<< (4*HandlePtr->kChannelNo),
                (4*HandlePtr->kChannelNo),
                HandlePtr->kGainControl, 32);
     } else {
    WR_REG_SIZE(SHS0->GNCTR10,
                0xF<< (4*HandlePtr->kChannelNo),
                (4*HandlePtr->kChannelNo),
                HandlePtr->kGainControl, 32);
    }
    <%}%>
    /* change the state to the Initialized */
    HandlePtr->DynamicHandlePtr->State = ADCCH001_INITIALIZED;
    Status &= (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

}

/*******************************************************************************
 *                 API DEFINITION
 ******************************************************************************/

/**
 * This function initializes all instances of the ADCCH001 App
 */
void ADCCH001_Init(void)
{

  ADCGLOB001_Init();
<% ArrayList<String> appsList = (ArrayList<String>)(app.getApps("app/ADCCH001/"));
for (String appIns : appsList ) {
appInst = appIns.substring(appIns.lastIndexOf("/")+1);%>
 <% ChannelUri = app.getMappedUri(AppBaseuri + appInst +"/adcch"); %>
  <% if ((ChannelUri != null) && (ChannelUri.trim() != "")) { %>
/* Call the local function with the handle pointer for each instance */
  ADCCH001_lInit(&ADCCH001_Handle<%= appInst%>);
<%}%>
<%}%>

}

/**
 * This function resets all the channel and result registers.
 */
status_t ADCCH001_Deinit(const ADCCH001_HandleType* HandlePtr)
{
  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;
  uint8_t Index;
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State == ADCCH001_INITIALIZED))
  {
    GroupPtr->CHCTR[HandlePtr->kChannelNo] = (uint32_t)0x00;
    WR_REG( GroupPtr->EMUXCTR, VADC_G_EMUXCTR_EMUXCH_Msk,
            VADC_G_EMUXCTR_EMUXCH_Pos, (uint32_t)0x00);

    for(Index = (HandlePtr->kEndResultRegNo);
          Index <= (HandlePtr->kStartResultRegNo);
        Index++)
    {
      GroupPtr->RCR[Index] = (uint32_t)0x00;
      GroupPtr->RES[Index] = (uint32_t)0x00;
    }
    if(HandlePtr->kBoundaryFlagEnable == (uint8_t)1)
    {
      CLR_BIT(GroupPtr->BFL,
                (((uint32_t)16 + (uint32_t)HandlePtr->kStartResultRegNo)));
      <% if(Is45Device != 1) {%>
      GroupPtr->BFLC = (uint32_t)0x00;
      <%}%>
    }
    HandlePtr->DynamicHandlePtr->State = ADCCH001_UNINITIALIZED;
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function assigns the alias channel number
 */
status_t ADCCH001_SetAlias(const ADCCH001_HandleType* HandlePtr,
                           uint8_t ChannelNo)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((ChannelNo > (uint8_t)7))
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      ((HandlePtr->kChannelNo == (uint8_t)0) ||
      (HandlePtr->kChannelNo == (uint8_t)1)))
  {
    HandlePtr->ADCGrPtr->ALIAS &=
                      ~((uint32_t)0x1F << (HandlePtr->kChannelNo * (uint8_t)8));
    HandlePtr->ADCGrPtr->ALIAS |=
                  ((uint32_t)ChannelNo << (HandlePtr->kChannelNo * (uint8_t)8));
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function enables the boundary flag for result register 0, 1, 2 or 3.
 */
status_t ADCCH001_EnableBoundaryFlag(const ADCCH001_HandleType* HandlePtr,
                                     uint8_t FlagNo)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((FlagNo > (uint8_t)3))
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))
  {
    SET_BIT(HandlePtr->ADCGrPtr->BFL, ((uint32_t)FlagNo + (uint32_t)16));
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function disables the boundary flag for result register 0, 1, 2 or 3.
 */
status_t ADCCH001_DisableBoundaryFlag(const ADCCH001_HandleType* HandlePtr,
                                      uint8_t FlagNo)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((FlagNo > (uint8_t)3))
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))
  {
    CLR_BIT(HandlePtr->ADCGrPtr->BFL, ((uint32_t)FlagNo + (uint32_t)16));
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This function selects the input class for the channel.
 */
status_t ADCCH001_SelectInputClass(const ADCCH001_HandleType* HandlePtr,
                                   ADCCH001_InputClassType Class)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((Class > (ADCCH001_InputClassType)3))
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo],
            VADC_G_CHCTR_ICLSEL_Msk,
            VADC_G_CHCTR_ICLSEL_Pos,
            (uint32_t)Class
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This function configures the channel event mode to generate the
 * channel interrupt
 */
status_t ADCCH001_SelectChEvtMode(const ADCCH001_HandleType* HandlePtr,
                                  ADCCH001_ChanEvtModeType Mode)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((Mode > (ADCCH001_ChanEvtModeType)3))
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }
  else if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)
  {
    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo],
            VADC_G_CHCTR_CHEVMODE_Msk,
            VADC_G_CHCTR_CHEVMODE_Pos,
            (uint32_t)Mode
          );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function selects the upper boundary for limit checking function.
 * This is the upper delta for Fast Compare Mode.
 */
status_t ADCCH001_SelectUpperBoundary(const ADCCH001_HandleType* HandlePtr,
                                      ADCCH001_BoundaryType UBoundary)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((UBoundary > (ADCCH001_BoundaryType)3))
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo],
            VADC_G_CHCTR_BNDSELU_Msk,
            VADC_G_CHCTR_BNDSELU_Pos,
            (uint32_t)UBoundary
          );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function selects the lower boundary for limit checking function.
 * This is the lower delta for Fast Compare Mode.
 */
status_t ADCCH001_SelectLowerBoundary(const ADCCH001_HandleType* HandlePtr,
                                      ADCCH001_BoundaryType LBoundary)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((LBoundary > (ADCCH001_BoundaryType)3))
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo],
            VADC_G_CHCTR_BNDSELL_Msk,
            VADC_G_CHCTR_BNDSELL_Pos,
            (uint32_t)LBoundary
          );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function returns the result of the normal mode ADC conversion.
 */
status_t ADCCH001_GetResult(const ADCCH001_HandleType* HandlePtr,
                            uint16_t* ResultPtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;
  uint32_t TempResult;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    TempResult = GroupPtr->RES[HandlePtr->kEndResultRegNo];
    /* If valid flag is set */
    if(((TempResult & VADC_G_RES_VF_Msk) >> VADC_G_RES_VF_Pos) == (uint32_t)1)
    {
      HandlePtr->DynamicHandlePtr->Result =
          (uint16_t)(TempResult & VADC_G_RES_RESULT_Msk);
      *ResultPtr = HandlePtr->DynamicHandlePtr->Result;
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    /* If data is old, then send error as invalid result */
    else
    {
      *ResultPtr = HandlePtr->DynamicHandlePtr->Result;
      Status = (uint32_t)ADCCH001_INVALID_RESULT;
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function returns the result of the normal mode ADC conversion without
 * checking the valid bitfield.
 */
uint16_t ADCCH001_GetFastResult(const ADCCH001_HandleType* HandlePtr)
{
     VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;

     return (uint16_t)(GroupPtr->RES[HandlePtr->kEndResultRegNo] &
                         (uint32_t)VADC_G_RES_RESULT_Msk);
}

/**
 * If result register is 0 then Indicates the setting of the external
 * multiplexer controlled by the ADC EMUX controller. This setting corresponds
 * to the current result. In case of other result register different
 * from result register 0 is used, then this information is not relevant.
 */
status_t ADCCH001_GetEmux(const ADCCH001_HandleType* HandlePtr,
                          uint8_t* EmuxPtr)
{
      status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
      VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;

      if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
          (HandlePtr->kCompareMode == (uint8_t)0))
      {
          if((HandlePtr->kEndResultRegNo == 0) &&
                 (((GroupPtr->EMUXCTR & VADC_G_EMUXCTR_EMUXMODE_Msk) >>\
                 VADC_G_EMUXCTR_EMUXMODE_Pos) > 0))
          {
              *EmuxPtr = (uint8_t)((GroupPtr->RESD[0] &
              (uint32_t)VADC_G_RES_EMUX_Msk) >> (uint32_t)VADC_G_RES_EMUX_Pos);
              Status = (uint32_t) DAVEApp_SUCCESS;
          }
          else
          {
              Status = (uint32_t)ADCCH001_INVALID_RESULT;
              DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
          }
      }
      else
      {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
      }

      return Status;
}

/**
 * This function returns the result of the fast compare ADC conversion.
 */
status_t ADCCH001_GetFastCompareResult(const ADCCH001_HandleType* HandlePtr,
                                       uint8_t* ResultPtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;
  uint32_t TempResult;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)1))
  {
    TempResult = GroupPtr->RES[HandlePtr->kEndResultRegNo];
    /* If valid flag is set */
    if(((TempResult & VADC_G_RES_VF_Msk) >> VADC_G_RES_VF_Pos) == (uint32_t)1)
    {
      HandlePtr->DynamicHandlePtr->FastCompResult = (uint8_t)RD_REG(TempResult,
                                                    VADC_G_RES_FCR_Msk,
                                                    VADC_G_RES_FCR_Pos
                                                   );
      *ResultPtr = HandlePtr->DynamicHandlePtr->FastCompResult;
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
    /* If data is old, then send error as invalid result */
    else
    {
      *ResultPtr = HandlePtr->DynamicHandlePtr->FastCompResult;
      Status = (uint32_t)ADCCH001_INVALID_RESULT;
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function sets the compare value for the Fast Compare Mode.
 * Compare value should 10-bit value.
 */
status_t ADCCH001_SetCompareValue(const ADCCH001_HandleType* HandlePtr,
                                  uint16_t CompVal)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if(CompVal > (uint16_t)0x3FF)
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      ((HandlePtr->kCompareMode == (uint8_t)1)))
  {
    WR_REG( HandlePtr->ADCGrPtr->RES[HandlePtr->kStartResultRegNo],
            VADC_G_RES_RESULT_Msk,
            VADC_G_RES_RESULT_Pos,
            ((uint32_t)CompVal << (uint8_t)2)
          );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function enables the channel as a priority channel.
 */
status_t ADCCH001_EnablePriorityChannel(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))
  {
    SET_BIT(HandlePtr->ADCGrPtr->CHASS, (HandlePtr->kChannelNo));
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function disables the channel as a priority channel.
 */
status_t ADCCH001_DisablePriorityChannel(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))
  {
    CLR_BIT(HandlePtr->ADCGrPtr->CHASS, (HandlePtr->kChannelNo));
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function enables the  Result event.
 */
status_t ADCCH001_EnableResultEvt(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    SET_BIT( HandlePtr->ADCGrPtr->RCR[HandlePtr->kEndResultRegNo],
             VADC_G_RCR_SRGEN_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function disables the  Result event.
 */
status_t ADCCH001_DisableResultEvt(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    CLR_BIT( HandlePtr->ADCGrPtr->RCR[HandlePtr->kEndResultRegNo],
             VADC_G_RCR_SRGEN_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This function checks whether Result event flag is set.
 */
status_t ADCCH001_GetResultEvtFlag(const ADCCH001_HandleType* HandlePtr,
                                   uint8_t* EvtStatus)
{

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    *EvtStatus = (uint8_t)RD_REG( HandlePtr->ADCGrPtr->REFLAG,
                        ((uint32_t)0x01 << HandlePtr->kEndResultRegNo),
                        (uint32_t)HandlePtr->kEndResultRegNo
                 );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function checks whether Channel event flag is set.
 */
status_t ADCCH001_GetChannelEvtFlag(const ADCCH001_HandleType* HandlePtr,
                                    uint8_t* EvtStatus)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)
  {
    *EvtStatus = (uint8_t)RD_REG(HandlePtr->ADCGrPtr->CEFLAG,
                        ((uint32_t)0x01 << HandlePtr->kChannelNo),
                        (uint32_t)HandlePtr->kChannelNo
                 );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This will set the result event flag through software.
 */
status_t ADCCH001_SetResultEvtFlag(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    SET_BIT( HandlePtr->ADCGrPtr->REFLAG,
             HandlePtr->kEndResultRegNo
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This will set the channel event flagv through software
 */
status_t ADCCH001_SetChannelEvtFlag(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)
  {
    SET_BIT( HandlePtr->ADCGrPtr->CEFLAG,
             HandlePtr->kChannelNo
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This will clear the pending result event flag
 */
status_t ADCCH001_ClearResultEvtFlag(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    SET_BIT( HandlePtr->ADCGrPtr->REFCLR,
             HandlePtr->kEndResultRegNo
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This will clear the pending channel event flag
 */
status_t ADCCH001_ClearChannelEvtFlag(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)
  {
    SET_BIT( HandlePtr->ADCGrPtr->CEFCLR,
             HandlePtr->kChannelNo
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This function slects the Broken Wire Detection Channel.
 */
status_t ADCCH001_SetBWDChannel(const ADCCH001_HandleType* HandlePtr,
                                ADCCH001_BWDType BWDChannel)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo],
            VADC_G_CHCTR_BWDCH_Msk,
            VADC_G_CHCTR_BWDCH_Pos,
            (uint32_t)BWDChannel
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This will enable the Broken Wire Detection feature.
 */
status_t ADCCH001_EnableBWD(const ADCCH001_HandleType* HandlePtr)
{

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    SET_BIT( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo],
             VADC_G_CHCTR_BWDEN_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This will disable the Broken Wire Detection feature.
 */
status_t ADCCH001_DisableBWD(const ADCCH001_HandleType* HandlePtr)
{

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    CLR_BIT( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo],
             VADC_G_CHCTR_BWDEN_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * This will enable wait for read mode of the result register
 */
status_t ADCCH001_EnableWaitForRead(const ADCCH001_HandleType* HandlePtr)
{

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
      WR_REG( HandlePtr->ADCGrPtr->RCR[HandlePtr->kStartResultRegNo],
              VADC_G_RCR_WFR_Msk,
              VADC_G_RCR_WFR_Pos,
              (uint32_t)0x1
             );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}


/**
 * This will disable wait for read mode of the result register
 */
status_t ADCCH001_DisableWaitForRead(const ADCCH001_HandleType* HandlePtr)
{

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
      WR_REG( HandlePtr->ADCGrPtr->RCR[HandlePtr->kStartResultRegNo],
              VADC_G_RCR_WFR_Msk,
              VADC_G_RCR_WFR_Pos,
              (uint32_t)0x0
             );
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  else
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
  }

  return Status;
}

/**
 * @endcond
 */
